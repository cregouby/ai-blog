---
title: "Hierarchical multilabel classification with Tabnet"
description: >
  Tabnet package, in addition to covering task like self-supervised learning and 
  multi-outcome classification, now implement a hierarchical classification head 
  able to perform tasks like species classification. In this blog post, we propose 
  to revisit the famous dataset of `zooplankton` from the book 
  Data Mining Applications with R, Chap.12.
author:
  - name: Christophe Regouby
    affiliation: Airbus
    affiliation_url: https://www.airbus.com/
slug: hierarchical
date: last-modified
categories:
  - Torch
  - Tabnet
  - R
  - hierarchical classifiation
output:
  distill::distill_article:
    self_contained: false
    toc: true
preview: images/MTLG.2005-05-24.H1+B2_170.jpg
---


```{r}
#| label: setup
#| output: false
#| warning: false
library(tabnet)
library(dplyr)
library(tibble)
library(stringr)
library(tidyr)
library(data.tree)
library(ggplot2)
library(recipes)
library(rsample)
```

## First look on Dataset

The `plankton` training dataset, courtesy of Pr. Ph. Grosjean,  offers us a challenge to apply hierarchical classification on. 


```{r}
#| label: raw dataset
zooplankton <- readRDS(here::here("../../_packages/tabnet_experiments/zooplankton_train.rds"))
head(zooplankton, 4)
attr(zooplankton, "path")
```

We can see that  
   - labels are in `Class` column.  
   - each observation is named through its rowname.  
   - attributes are in all other columns .   
   - the hierarchy of labels are in `attr(, "path")`.  

For instance, there is "Copepoda/Podoplea/Poecilostomatoida" which means that Class  "Poecilostomatoida" in the data.frame is part of a supercategory "Podoplea" (together with "Cyclopoida" and "Harpacticoida"). At an even higher level, "Copepoda" contains both "Podoplea" and "Gymnoplea". This is a very basic but classical way of encoding the hierarchy of labels.
   
Obviously this needs to be transformed into data format of choice for `{tabnet}` to run hierarchical multi-label classification: the `Node` format from package `{data.tree}`. 

We can now proceed with this transformation

### Data format transformation

The convenient way (among other) to turn a tabular dataset into a `Node` tree format consists in glueing the different columns representing the class hierarchy into a column named `pathString` using the `/` separator. This reserved column name and separator is natively recognized by the {data.tree} package for smooth conversion with the `as.Node()` command. 

Another constraint to encode the tabular data into a `Node` tree is to have a tree root, i.e. a constant column being the parent of each node of the graph. We will chose "zooplankton" here for the tree root.
Then we also need to have a leaf on the tree being a placeholder for all the predictor values of each sample. For this, we will use the row names, conveniently provided by the `rownames_to_column()` function, that will create a `rowname` column.

To do so, we will use extensively {dplyr} and {stringr}.

First step is to extract the `Class` from the `path` attribute in the original dataset, then we join it with the predictors.


```{r}
#| label: data.tree
#| output: asis
zoo_hierarchy <- tibble(pathString = attr(zooplankton, "path")) %>% 
  mutate(Class = str_extract(pathString, "[^/]+$"))
```

We prepend the `path` with "zooplankton" into the reserved `pathString` to have a root of the data.tree, and append the rowid to have one unique `pathString` value per observation. Those two additional levels in the hierarchy are needed as they will be dropped by {tabnet}.

```{r}
zoo_dataset <- zooplankton %>% 
  rownames_to_column() %>% 
  left_join(zoo_hierarchy, by = "Class") %>% 
  select(-Class)

zoo_tree <- zoo_dataset %>%
  mutate(pathString = paste("zooplankton", pathString, rowname, sep = "/")) %>% 
  select( -rowname) %>% 
  as.Node()
```

We finally turn it into a {data.tree} `Node` and we can verify that we get the expected data:


```{r}
print(zoo_tree, "Area", "Range", "Perim.", limit = 10)
```

## Data preparation

### Initiall split
```{r}
set.seed(202307)
zoo_split <- initial_split(
  zoo_dataset,
  prop = .8, strata = "pathString"
)
# few observation in the test-set to look at
minitest_ids <- testing(zoo_split)[sample.int(nrow(testing(zoo_split)), 8), "rowname"] 
```


Tidymodels {workflow} is not natively available with {tabnet} for `Node` formatted datasets for now. So we need to separately run **split** then **prepare** and **bake** with datasets before turning them to a `Node` objects.  
Data transformation includes numerical values normalization as recommended by the authors of [TabNet paper]((https://arxiv.org/abs/1908.07442).  

We will actually use {recipes} function to do it, but the full preparation shall be done including (`prep()` + `bake()`)

```{r}
zoo_prep <- zoo_split %>% 
  training() %>% 
  recipe(pathString ~ .) %>% 
  step_normalize(all_numeric_predictors()) %>% 
  prep()

zoo_train_baked <- zoo_prep %>% 
  bake(new_data = NULL)

zoo_test_baked <- zoo_prep %>% 
  bake(new_data = zoo_split %>% testing())

zoo_minitest_baked <- zoo_prep %>% 
  bake(new_data = zoo_dataset %>% filter(rowname %in% minitest_ids))

zoo_train_tree <- zoo_train_baked %>% 
  mutate(pathString = paste("zooplankton", pathString, rowname, sep = "/")) %>% 
  select( -rowname) %>% 
  as.Node()

zoo_minitest_multi <- zoo_minitest_baked %>%
  select(-rowname) %>% 
  separate_wider_delim(cols = pathString, delim = "/", names = c("level_2", "level_3", "level_4" ), too_few = "align_start") %>% 
  mutate(level_4 = coalesce(level_4, level_3)) %>% 
  mutate_if(is.character, as.factor)

```

::: {.callout-note}
## Note about `rowname`
`rowname` has been turn into column to be used as last (dropped) level of the hierarchy because the `as.Node()` function is reordoning rows (that are in the same hierarchy) and columns (alphabetically). It will be used to get back to observations for side-by-side comparison.
:::

## Tabnet modeling

We are now ready to fit the hierarchical multi-label classification model in passing the Node object to it:

### Model design

```{r}
#| label: model design
config <- tabnet_config(penalty = .05, decision_width = 6, attention_width = 6, num_steps = 3, 
                        lr_scheduler = "reduce_on_plateau", early_stopping_patience = 5L, step_size = 5,
                        valid_split = .1, epoch = 140, checkpoint_epochs = 30, verbose = FALSE)
```

### Hierarchical Model training

```{r}
#| label: hierarchical model training for 140 epoch
zoo_model_hier <- tabnet_fit(zoo_train_tree, config = config)
```
From this point, the natural way-forward in a data-science workflow is to diagnose the model. But let's keep this part for later on in a side-by-side comparison with standard multi-outcome classifier.

### Look at inference results

```{r}
# zoo_hat_hier <- bind_cols(
#     predict(zoo_model_hier, zoo_minitest_tree),
#     tabnet:::node_to_df(zoo_minitest_tree)$y
#   )
zoo_hat_hier <- bind_cols(
    predict(zoo_model_hier, zoo_minitest_multi),
    zoo_minitest_multi %>% select(starts_with("level_"))
  )
knitr::kable(
  zoo_hat_hier
)
```


## Comparison with non-hierarchical multi-label classifier

But wait, is there any advantage here against the same workflow with a standard multi-label classifier? We have the opportunity here to compare side by side with the same hyperparameters as {tabnet} can do both.

### Data preparation

We need to reconstruct the 3 level_ columns out of the `pathString` variable. This is done with the `tidyr::separate_` function.
As few of the class hierarchy only contains 2 levels, we need to impute missing entries in `level_4` with the one in `level_3` to avoid the strict check in multi-outcome formula, and prevent the message

```
Error in `tabnet_bridge()` at tabnet/R/hardhat.R:154:2:
! Error: found missing values in the level_3 outcome column.
```

```{r}
zoo_train_multi <- zoo_train_baked %>% 
  select(-rowname) %>% 
  separate_wider_delim(cols = pathString, delim = "/", names = c("level_2", "level_3", "level_4" ), too_few = "align_start") %>% 
  mutate(level_4 = coalesce(level_4, level_3)) %>% 
  mutate_if(is.character, as.factor)

zoo_test_multi <- zoo_test_baked %>%
  select(-rowname) %>% 
  separate_wider_delim(cols = pathString, delim = "/", names = c("level_2", "level_3", "level_4" ), too_few = "align_start") %>% 
  mutate(level_4 = coalesce(level_4, level_3)) %>% 
  mutate_if(is.character, as.factor)

```


### Multilabel Model training

we will use the convenient formula to specify a tabnet model training on the same dataset with the same hyperparameters.

```{r}
#| label: multi-label model training for 140 epoch
zoo_model_multi <- tabnet_fit(level_2 + level_3 + level_4 ~ ., data = zoo_train_multi, config = config)
```
### Look at inference results

```{r}
zoo_hat_multi <- bind_cols(
    predict(zoo_model_multi, zoo_minitest_multi),
    zoo_minitest_multi %>% select(starts_with("level_"))
  )
knitr::kable(
  zoo_hat_multi
)


```

## Side-by-side model diagnostic

### Model fitting diagnostic

Let's diagnose the both model fitting loss
```{r}
#| label: fig-fit
#| layout-ncol: 2
#| fig-cap: "Model training diagnostic plot"
#| fig-subcap: 
#|   - "Hierarchical Classifier"
#|   - "Multi-outcome Classifier"

autoplot(zoo_model_hier)
autoplot(zoo_model_multi)
```
### Variable importance
```{r}
#| label: fig-vip
#| layout-ncol: 2
#| fig-cap: "Global model variable importance plot"
#| fig-subcap: 
#|   - "Hierarchical Classifier"
#|   - "Multi-outcome Classifier"
vip::vip(zoo_model_hier)
vip::vip(zoo_model_multi)
```


### Model attention map

Explain the model
```{r}
#| label: fig-attention
#| layout-ncol: 2
#| fig-cap: "Model attention map on testset observations"
#| fig-subcap: 
#|   - "Hierarchical Classifier"
#|   - "Multi-outcome Classifier"
zoo_explain_hier <- tabnet_explain(zoo_model_hier, zoo_train_tree)
autoplot(zoo_explain_hier, quantile = .99)

zoo_explain_multi <- tabnet_explain(zoo_model_multi, zoo_train_multi)
autoplot(zoo_explain_multi, quantile = .99)
```

## Hierarchy violation count
```{r}
# simple multi-label
pred_multi <- predict(zoo_model_multi, zoo_test_multi) %>% 
  reframe(hierarchy = paste(`.pred_class_level_2`, .pred_class_level_3, .pred_class_level_4, sep = "/")) %>% 
  mutate(violation = !(hierarchy %in% zoo_hierarchy$pathString))


```

