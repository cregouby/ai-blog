---
title: "Hierarchical multilabel classification with Tabnet"
description: >
  Tabnet package, in addition to covering task like self-supervised learning and 
  multi-outcome classification, now implement a hierarchical classification head 
  able to perform tasks like species classification. In this blog post, we propose 
  to revisit the famous dataset of `zooplankton` from the book 
  Data Mining Applications with R, Chap.12.
author:
  - name: Christophe Regouby
    affiliation: Airbus
    affiliation_url: https://www.airbus.com/
slug: safetensors
date: 2023-06-22
categories:
  - Torch
  - Tabnet
  - R
  - hierarchical classifiation
output:
  distill::distill_article:
    self_contained: false
    toc: true
preview: images/MTLG.2005-05-24.H1+B2_170.jpg
---


```{r}
#| label: setup
library(tabnet)
library(dplyr)
library(tibble)
library(stringr)
library(data.tree)
library(ggplot2)
library(recipes)
```

## Dataset

The `plankton` training dataset, courtesy of Ph. Grosjean,  offers us a challenge to apply hierarchical classification on. 

Let's first turn the dataset into a `data.tree` format as expected by `{tabnet}`

### First look on data

```{r}
#| label: raw dataset
zooplankton <- readRDS("../../../../_packages/tabnet_experiments/zooplankton_train.rds")
head(zooplankton, 4)
attr(zooplankton, "path")
```

We can see that
   - labels are in Class
   - attributes are in all other columns
   - the hierarchy of labels are in attr(, "path"). For instance, there is "Copepoda/Podoplea/Poecilostomatoida" which means that Class` "Poecilostomatoida" in the data.frame is part of a supercategory "Podoplea" (together with "Cyclopoida" and "Harpacticoida"). At an even higher level, "Copepoda" contains both "Podoplea" and "Gymnoplea". This is a very basic but classical way of encoding the hierarchy of labels.
   
Obviously this needs to be transformed into data format of choice for {tabnet} to run hierarchical multi-label classification: the `Node` format from package {data.tree}. 


### Data formating

The convenient way (among other) to turn a tabular dataset into a `Node` tree format consists in glueing the different columns representing the class hierarchy into a column named `pathString` using the `/` separator. This reserved column name and separator is natively recognized by the {data.tree} package for smooth conversion with the `as.Node()` command. 

Another constraint to encode the tabular data into a `Node` tree is to have a tree root, i.e. a constant column being the parent of each node of the graph. We will chose "zooplankton" here for the tree root.
Then we also need to have a leaf on the tree being a placeholder for all the predictor values of each sample. For this, we will use the row id, conveniently provided by the `rowid_to_column()` function.

To do so, we will use extensively {dplyr} and {stringr}.

First step is to extract the `Class` from the `path` attribute in the original dataset, then we join it with the predictors.


```{r}
#| label: data.tree
#| output: asis
zoo_hierarchy <- tibble(pathString = attr(zooplankton, "path")) %>% 
  mutate(Class = str_extract(pathString, "[^/]+$"))
```

We prepend the `path` with "zooplankton" into the reserved `pathString` to have a root of the data.tree, and append the rowid to have one unique `pathString` value per sample. Those two additional levels in the hierarchy are needed as they will be dropped by {tabnet}.

```{r}
zoo_tree <- zooplankton %>% 
  rowid_to_column() %>% 
  left_join(zoo_hierarchy, by="Class") %>%
  mutate(pathString = paste("zooplankton", pathString, rowid, sep = "/")) %>% 
  select(-Class, -rowid) %>% 
  as.Node()
```

We finally turn it into a {data.tree} `Node` and we can verify that we get the expected data:


```{r}
print(zoo_tree, "Area", "Range", "Perim.", limit = 10)
```

### Data preparation

{recipes} workflow is not available this `Node` dataset for now. So we should have prepare the dataset before turning it to a `Node` object, via numerical values normalization: 
```{r}
zoo_baked <- recipes::recipe(zooplankton) %>% 
  step_normalize(all_numeric_predictors()) %>% 
  prep() %>% 
  bake()

zoo_tree <- zoo_baked %>% 
  rowid_to_column() %>% 
  left_join(zoo_hierarchy, by="Class") %>%
  mutate(pathString = paste("zooplankton", pathString, rowid, sep = "/")) %>% 
  select(-Class, -rowid) %>% 
  as.Node()
```



## Tabnet modeling

We are now ready to model

```{r}
#| label:model training for 50 epoch
zoo_model <- tabnet_fit(zoo_tree, valid_split = .1, epochs = 50, verbose = T, num_workers = 5L)
```

Let's diagnose the model training
```{r}
autoplot(zoo_model)
```

Explain the model
```{r}
zoo_explain <- tabnet_explain(zoo_model, zoo_tree)
autoplot(zoo_explain, quantile = .95)
```

