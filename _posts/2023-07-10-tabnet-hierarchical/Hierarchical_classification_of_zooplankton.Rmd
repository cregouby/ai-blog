---
title: "Hierarchical multilabel classification with Tabnet"
description: >
  Tabnet package, in addition to covering task like self-supervised learning and 
  multi-outcome classification, now implement a hierarchical classification head 
  able to perform tasks like species classification. In this blog post, we propose 
  to revisit the famous dataset of `zooplankton` from the book 
  Data Mining Applications with R, Chap.12.
author:
  - name: Christophe Regouby
    affiliation: Airbus
    affiliation_url: https://www.airbus.com/
slug: hierarchical
date: last-modified
categories:
  - Torch
  - Tabnet
  - R
  - hierarchical classifiation
output:
  distill::distill_article:
    self_contained: false
    toc: true
preview: images/MTLG.2005-05-24.H1+B2_170.jpg
---


```{r}
#| label: setup
#| output: false
#| warning: false
library(tabnet)
library(dplyr)
library(tibble)
library(stringr)
library(data.tree)
library(ggplot2)
library(recipes)
library(rsample)
```

## First look on Dataset

The `plankton` training dataset, courtesy of Ph. Grosjean,  offers us a challenge to apply hierarchical classification on. 

Let's first turn the dataset into a `data.tree` format as expected by `{tabnet}`



```{r}
#| label: raw dataset
zooplankton <- readRDS(here::here("../../_packages/tabnet_experiments/zooplankton_train.rds"))
head(zooplankton, 4)
attr(zooplankton, "path")
```

We can see that  
   - labels are in `Class` column.  
   - attributes are in all other columns  
   - the hierarchy of labels are in `attr(, "path")`.  

For instance, there is "Copepoda/Podoplea/Poecilostomatoida" which means that Class  "Poecilostomatoida" in the data.frame is part of a supercategory "Podoplea" (together with "Cyclopoida" and "Harpacticoida"). At an even higher level, "Copepoda" contains both "Podoplea" and "Gymnoplea". This is a very basic but classical way of encoding the hierarchy of labels.
   
Obviously this needs to be transformed into data format of choice for {tabnet} to run hierarchical multi-label classification: the `Node` format from package {data.tree}. 


### Data formating

The convenient way (among other) to turn a tabular dataset into a `Node` tree format consists in glueing the different columns representing the class hierarchy into a column named `pathString` using the `/` separator. This reserved column name and separator is natively recognized by the {data.tree} package for smooth conversion with the `as.Node()` command. 

Another constraint to encode the tabular data into a `Node` tree is to have a tree root, i.e. a constant column being the parent of each node of the graph. We will chose "zooplankton" here for the tree root.
Then we also need to have a leaf on the tree being a placeholder for all the predictor values of each sample. For this, we will use the row names, conveniently provided by the `rownames_to_column()` function, that will create a `rowname` column.

To do so, we will use extensively {dplyr} and {stringr}.

First step is to extract the `Class` from the `path` attribute in the original dataset, then we join it with the predictors.


```{r}
#| label: data.tree
#| output: asis
zoo_hierarchy <- tibble(pathString = attr(zooplankton, "path")) %>% 
  mutate(Class = str_extract(pathString, "[^/]+$"))
```

We prepend the `path` with "zooplankton" into the reserved `pathString` to have a root of the data.tree, and append the rowid to have one unique `pathString` value per sample. Those two additional levels in the hierarchy are needed as they will be dropped by {tabnet}.

```{r}
zoo_tree <- zooplankton %>% 
  rownames_to_column() %>% 
  left_join(zoo_hierarchy, by="Class") %>%
  mutate(pathString = paste("zooplankton", pathString, rowname, sep = "/")) %>% 
  select(-Class, -rowname) %>% 
  as.Node()
```

We finally turn it into a {data.tree} `Node` and we can verify that we get the expected data:


```{r}
print(zoo_tree, "Area", "Range", "Perim.", limit = 10)
```

## Data preparation

### Initiall split
```{r}
set.seed(202307)
zoo_split <- initial_split(zooplankton, prop = .8, strata = "Class")
```


Tidymodels {workflow} is not natively available with {tabnet} for `Node` datasets for now. So we need to manually **split** then **prepare** and **bake** the datasets before turning them to a `Node` objects, via numerical values normalization as recommended by the authors of [TabNet paper]((https://arxiv.org/abs/1908.07442).  

We will actually use {recipes} function to do it, but the full preparation shall be done including (`prep()` + `bake()`)

```{r}
zoo_prep <- zoo_split %>% 
  training() %>% 
  recipe() %>% 
  step_normalize(all_numeric_predictors()) %>% 
  prep()

zoo_train_baked <- zoo_prep %>% 
  bake(new_data = NULL)

zoo_test_baked <- zoo_prep %>% 
  bake(new_data = zoo_split %>% testing())

zoo_train_tree <- zoo_train_baked %>% 
  rowid_to_column() %>% 
  left_join(zoo_hierarchy, by = "Class") %>%
  mutate(pathString = paste("zooplankton", pathString, rowid, sep = "/")) %>% 
  select(-Class, -rowid) %>% 
  as.Node()

zoo_test_tree <- zoo_test_baked %>% 
  rowid_to_column() %>% 
  left_join(zoo_hierarchy, by = "Class") %>%
  mutate(pathString = paste("zooplankton", pathString, rowid, sep = "/")) %>% 
  select(-Class, -rowid) %>% 
  as.Node()
```



## Tabnet modeling

We are now ready to fit the hierarchical multi-label classification model in passing the Node object to it:

### Model design

```{r}
#| label: model design
config <- tabnet_config(penalty = .05, decision_width = 6, attention_width = 6, num_steps = 3, 
                        lr_scheduler = "reduce_on_plateau", early_stopping_patience = 5L, step_size = 5,
                        valid_split = .1, epoch = 140, checkpoint_epochs = 30, verbose = TRUE)
```

### Model training

```{r}
#| label: model training for 140 epoch
zoo_model <- tabnet_fit(zoo_train_tree, config = config)
```

### Training diagnostic

Let's diagnose the model training
```{r}
autoplot(zoo_model)
```
### Variable importance
```{r}
vip::vip(zoo_model)
```


### Model attention map

Explain the model
```{r}
zoo_explain <- tabnet_explain(zoo_model, zoo_train_tree)
autoplot(zoo_explain, quantile = .99)
```
### Look at inference results

```{r}
zoo_hat <- bind_cols(
    predict(zoo_model, zoo_test_tree),
    tabnet:::node_to_df(zoo_test_tree)$y
  )
sample_n(zoo_hat, size = 5)

```

